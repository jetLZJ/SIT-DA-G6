import streamlit as st
import pandas as pd
from pathlib import Path
import sqlalchemy

from app import data_loader


def page_data_and_schema(engine: sqlalchemy.engine.Engine | None):
    st.header('Module 1 — Data Fundamentals & SQL')
    st.markdown('''
    Executive summary
    ''')

    st.subheader('Why transform wide -> long')
    st.markdown(
        """- Wide tables encode periods (years) as separate columns which makes joins, time-series aggregations and window functions cumbersome.
- Long tables store one observation per row (year, dimension, value), which is easier to query and analyze in SQL."""
    )

    st.markdown('---')
    st.subheader('Resulting long tables (from M1 materials)')
    long_table_examples = [
        'unemployed_by_age_sex_long',
        'unemployed_by_qualification_sex_long',
        'unemployed_by_marital_status_sex_long',
        'unemployment_rate_by_occupation_long',
        'unemployed_by_previous_occupation_sex_long',
        'unemployed_pmets_by_age_long',
        'long_term_unemployed_pmets_by_age_long'
    ]
    st.table(pd.DataFrame({'long_table': long_table_examples}))

    st.markdown('---')
    st.subheader('SQL examples (from M1)')
    sql_create_example = """-- Create DB and example wide table
DROP DATABASE IF EXISTS labourtrendsdb;
CREATE DATABASE labourtrendsDB;
USE labourtrendsDB;

DROP TABLE IF EXISTS unemployed_by_age_sex_wide;
CREATE TABLE unemployed_by_age_sex_wide (
    gender VARCHAR(20),
    age_group VARCHAR(20),
    year_2014 DECIMAL(5,1),
    -- ... year_2015 .. year_2024
    year_2024 DECIMAL(5,1)
);
"""
    sql_unpivot_example = """-- Unpivot / wide -> long pattern
DROP TABLE IF EXISTS unemployed_by_age_sex_long;
CREATE TABLE unemployed_by_age_sex_long AS
    SELECT 2014 AS year, gender, age_group, year_2014 AS unemployed_count
    FROM unemployed_by_age_sex_wide
    UNION ALL
    SELECT 2015, gender, age_group, year_2015
    FROM unemployed_by_age_sex_wide
    -- ... repeat for each year through 2024
    UNION ALL
    SELECT 2024, gender, age_group, year_2024
    FROM unemployed_by_age_sex_wide;
"""

    st.code(sql_create_example, language='sql')
    st.code(sql_unpivot_example, language='sql')

    # Prefer serving separate appendix files from modules/ if present
    create_path = Path(__file__).parent.parent / 'modules' / 'm1_appendix_create.sql'
    transform_path = Path(__file__).parent.parent / 'modules' / 'm1_appendix_transform.sql'

    if create_path.exists() and transform_path.exists():
        st.download_button('Download Appendix 1 — Create SQL', create_path.read_bytes(), file_name='m1_appendix_create.sql', mime='text/sql')
        st.download_button('Download Appendix 2 — Transform SQL', transform_path.read_bytes(), file_name='m1_appendix_transform.sql', mime='text/sql')
    else:
        full_sql_appendix = sql_create_example + "\n" + sql_unpivot_example
        st.download_button('Download example SQL (appendix)', full_sql_appendix.encode('utf-8'), file_name='m1_appendix_example.sql', mime='text/sql')

    st.markdown('---')
    st.subheader('Validation & safe checks')
    st.markdown('Use these non-destructive checks to validate long tables created from the transformations.')

    if engine is None:
        st.warning('No DB connection available. Upload a CSV to inspect schema locally below.')
        uploaded = st.file_uploader('Upload CSV for schema inspection', type=['csv'], key='schema_uploader')
        if uploaded:
            df = pd.read_csv(uploaded)
            st.write('Sample rows')
            st.dataframe(df.head())
            st.write('Columns & dtypes')
            st.table(pd.DataFrame({'column': df.columns, 'dtype': [str(dt) for dt in df.dtypes]}))
        return

    try:
        tables = data_loader.list_tables(engine)
    except Exception as e:
        st.error(f'Failed to list tables: {e}')
        return

    st.write('Available tables in the database (showing up to 200):')
    st.write(tables[:200])

    existing_long = [t for t in long_table_examples if t in tables]
    missing_long = [t for t in long_table_examples if t not in tables]
    st.write('Expected long tables present:')
    st.write(existing_long or 'None')
    if missing_long:
        st.info('Expected long tables missing (these should be generated by the transformation scripts):')
        st.write(missing_long)

    validate_table = st.selectbox('Select a long table to run validation queries (safe)', options=existing_long or [])
    if validate_table:
        try:
            with engine.connect() as conn:
                result = conn.execute(sqlalchemy.text(f'SELECT COUNT(*) AS cnt FROM `{validate_table}`'))
                try:
                    count = result.scalar()
                except Exception:
                    row = result.fetchone()
                    count = row[0] if row is not None else 0
            st.write(f'Row count for {validate_table}: {int(count or 0):,}')
            preview = pd.read_sql(f'SELECT * FROM `{validate_table}` LIMIT 10', engine)
            st.dataframe(preview)
        except Exception as e:
            st.error(f'Validation query failed: {e}')

    st.markdown('---')
    st.subheader('Preview a wide table (example)')
    wide_choice = st.selectbox('Select a wide table to preview', options=[t for t in tables if t.endswith('wide')] or [])
    if wide_choice:
        try:
            df_wide = data_loader.read_table(engine, wide_choice, limit=5)
            st.write(f'Preview of {wide_choice}')
            st.dataframe(df_wide.head())
            st.markdown('Example unpivot SQL for this table:')
            st.code(sql_unpivot_example.replace('unemployed_by_age_sex_wide', wide_choice).replace('unemployed_by_age_sex_long', wide_choice.replace('_wide', '_long')), language='sql')
        except Exception as e:
            st.error(f'Failed to preview wide table: {e}')
